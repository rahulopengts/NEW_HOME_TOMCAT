/*
 * File Name: i2c_sw.c
 * Author: ram krishnan (rkris@wisense.in)
 * Created: Sep/22/2013
 *
 *
 * Copyright (c) <2013>, <ram krishnan>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */

#ifndef PLTFRM_I2C_SUPPORT_DISABLED

#include <typedefs.h>
#include <system.h>
#include <i2c_sw.h>

/*
 * 6.0 TRANSFERRING DATA
 * 6.1 Byte format
 * Every byte put on the SDA line must be 8-bits long. The number of
 * bytes that can be transmitted per transfer is unrestricted. Each byte
 * has to be followed by an acknowledge bit. Data is transferred with
 * the most significant bit (MSB) first (Figure 7). If a receiver can�t
 * receive another complete byte of data until it has performed some
 * other function, for example servicing an internal interrupt, it can hold
 * the clock line SCL LOW to force the transmitter into a wait state.
 * Data transfer then continues when the receiver is ready for another
 * byte of data and releases clock line SCL.
 * In some cases, it�s permitted to use a different format from the I2C-bus 
 * format (for CBUS compatible devices for example). A message which starts with 
 * such an address can be terminated by generation of a STOP condition, even 
 * during the transmission of a byte. In this case, no acknowledge is generated 
 * (see Section 9.1.3).
 * 
 * 6.2 Acknowledge
 * Data transfer with acknowledge is obligatory. The acknowledge-related clock 
 * pulse is generated by the master. The transmitter releases the SDA line (HIGH) 
 * during the acknowledge clock pulse. The receiver must pull down the SDA line 
 * during the acknowledge clock pulse so that it remains stable LOW during the 
 * HIGH period of this clock pulse (Figure 8). Of course, set-up and hold times
 * (specified in Section 15.0) must also be taken into account.
*/


/*
 * Clock and Data Transitions: The SDA pin is normally pulled high with an external 
 * device. Data on the SDA pin may change only during SCL low time periods. Data 
 * changes during SCL high periods will indicate a Start or Stop condition as 
 * defined below.
 *
 *  > Start condition: A high-to-low transition of SDA with SCL high.
 *  > Stop condition: A low-to-high transition of SDA with SCL high.
 * 
 * In the idle state, both SCL and SDA are high
 */



void __delay(void)
{
#ifdef PLTFRM_CHIRP_PWLA_ENA
   UINT8_t idx;
   for (idx=0; idx<10; idx++)
      PLTFRM_delay100MicroSecs();
#endif
}


UINT8_t I2C_SW_start(UINT8_t busId)
{
   UINT8_t rc = 1;
   volatile UINT8_t *regDir_p;
   UINT8_t sclBitNr, sdaBitNr;
   
   switch (busId)
   {
      case PLTFRM_I2C_SW_BUS_1_ID:
#ifdef WISENSE_HW_REV_4
           regDir_p = &P3DIR;
           sclBitNr = 0x2; // p3.2
           sdaBitNr = 0x3; // p3.3
#elif defined(WISENSE_HW_REV_5)
           regDir_p = &P1DIR;
           sclBitNr = 0x6; // p1.6
           sdaBitNr = 0x7; // p1.7
#elif defined(WISENSE_HW_REV_6)
           regDir_p = &P3DIR;
           sclBitNr = 0x7; // p3.7
           sdaBitNr = 0x6; // p3.6
#else
#error hw revision not specified !!
#endif
           break;
     
      default:
           rc = 0;
           break;
   }
   
   if (rc == 0)
       return rc;
   
   // Make sure both SCL and SDA are high at this point.

   (*regDir_p) |= (1 << sclBitNr);  // Set SCL low

   PLTFRM_delay10MicroSecs();
   __delay();

   (*regDir_p) &= ~(1 << sdaBitNr);  // Pull SDA high
   PLTFRM_delay10MicroSecs();
   __delay();

   (*regDir_p) &= ~(1 << sclBitNr);  // Pull SCL high

   // Start Setup Time (4 microsecs minimum)
   PLTFRM_delay10MicroSecs();  // 10 microseconds
   __delay();

   (*regDir_p) |= (1 << sdaBitNr);  // Set SDA LOW
   
   // Start hold time (Data low to clock low) (min value is 4 microsecs)
   PLTFRM_delay10MicroSecs();  // 10 microseconds
   __delay();
   
   (*regDir_p) |= (1 << sclBitNr);  // Set SCL low
   
   // Low period of SCL clock (min 4.7 microsecs)
   PLTFRM_delay10MicroSecs();  // 10 microseconds @ 100 KHz
   __delay();
   
   return rc;
}


UINT8_t I2C_SW_stop(UINT8_t busId)
{
   UINT8_t rc = 1;
   volatile UINT8_t *regDir_p;
   UINT8_t sclBitNr, sdaBitNr;
   
   switch (busId)
   {
      case PLTFRM_I2C_SW_BUS_1_ID:
#ifdef WISENSE_HW_REV_4
           regDir_p = &P3DIR;
           sclBitNr = 0x2; // p3.2
           sdaBitNr = 0x3; // p3.3           
#elif defined(WISENSE_HW_REV_5)
           regDir_p = &P1DIR;
           sclBitNr = 0x6; // p1.6
           sdaBitNr = 0x7; // p1.7
#elif defined(WISENSE_HW_REV_6)
           regDir_p = &P3DIR;
           sclBitNr = 0x7; // p3.7
           sdaBitNr = 0x6; // p3.6
#else
#error hw revision not specified !!
#endif
           break;
     
      default:
           rc = 0;
           break;
   }
   
   if (rc == 0)
       return rc;

   /*
    * <Stop condition>
    * Once all the data frames have been sent, the master will generate a stop condition.
    * Stop conditions are defined by a 0->1 (low to high) transition on SDA after a 0->1
    * transition on SCL, with SCL remaining high. During normal data writing operation,
    * the value on SDA should not change when SCL is high, to avoid false stop conditions.
    */
    
   (*regDir_p) |= (1 << sclBitNr);  // Set SCL low

   PLTFRM_delay10MicroSecs();
   __delay();
   
   (*regDir_p) |= (1 << sdaBitNr);   // Set SDA low
   
   // Data in setup time (minimum wait time is at most 250 nansecs @ 100 kHz)
   PLTFRM_delay10MicroSecs();  // 10 microseconds
   __delay();

   // Important to set the direction of boths pins IN so that leakage through
   // the resistors is avoided. If any pin is set to OUT and it's output is
   // set to low, it will provide a path for current from Vcc through the I2C
   // pull up resistors (3.3 v / 470000 -> 70 microamps)
   
   (*regDir_p) &= ~(1 << sclBitNr);  // Pull SCL high
   
   // STOP setup time (minimum wait time is at most 4 microsecs @ 100 kHz)
   PLTFRM_delay10MicroSecs();  // 10 microseconds
   __delay();
   
   (*regDir_p) &= ~(1 << sdaBitNr);  // Pull SDA high

   // Bus free time between a STOP and START condition
   // Minimum wait time is 4.7 microsecs @ 100 kHz
   PLTFRM_delay10MicroSecs();  // 10 microseconds
   __delay();

   return rc;  
}

UINT8_t I2C_SW_rdByte(UINT8_t busId,  UINT8_t *buff_p, UINT8_t ackCntrl)
{
   UINT8_t rc = 1, idx;
   volatile UINT8_t *regDir_p;
   volatile UINT8_t *regIn_p;
   UINT8_t sclBitNr, sdaBitNr;   
   UINT8_t rxData = 0;

   switch (busId)
   {
       case PLTFRM_I2C_SW_BUS_1_ID: 
#ifdef WISENSE_HW_REV_4
            regDir_p = &P3DIR;
            regIn_p = &P3IN;
            sclBitNr = 0x2; // p3.2
            sdaBitNr = 0x3; // p3.3
#elif defined(WISENSE_HW_REV_5)
           regDir_p = &P1DIR;
           regIn_p = &P1IN;
           sclBitNr = 0x6; // p1.6
           sdaBitNr = 0x7; // p1.7
#elif defined(WISENSE_HW_REV_6)
           regDir_p = &P3DIR;
           regIn_p = &P3IN;
           sclBitNr = 0x7; // p3.7
           sdaBitNr = 0x6; // p3.6
#else
#error hw revision not specified !!
#endif
            break;
            
       default:
            rc = 0;
            break;
   }
    
   if (rc == 0)
       return rc;
   
   *(regDir_p) &= ~(1 << sdaBitNr);  // Pull SDA high

   for (idx=0; idx<8; idx++)
   {  
        UINT8_t regVal;
        
        PLTFRM_delay10MicroSecs();
        __delay();
        
        *(regDir_p) &= ~(1 << sclBitNr);  // Pull SCL high
        
        PLTFRM_delay10MicroSecs();
        __delay();
        
        // Read the SDA line

        rxData <<= 1;
     
        regVal = *(regIn_p);
        if (regVal & (1 << sdaBitNr))
            rxData |= 0x1;
        
        PLTFRM_delay10MicroSecs();
        __delay();
        
        *(regDir_p) |= (1 << sclBitNr);  // Set SCL low
   }

   *buff_p = rxData;

   PLTFRM_delay10MicroSecs();
   __delay();

   /*
    * The receiver must pull down the SDA line during the acknowledge
    * clock pulse so that it remains stable LOW during the HIGH period of
    * this clock pulse. Of course, set-up and hold times must also be taken 
    * into account.
    */
   
   if (ackCntrl == I2C_ACK)
   {
       // Set SDA low ...
       *(regDir_p) |= (1 << sdaBitNr);  // Set SDA low
   }
   
   PLTFRM_delay10MicroSecs();
   __delay();
   
   *(regDir_p) &= ~(1 << sclBitNr);  // Pull SCL high
   
   PLTFRM_delay10MicroSecs();
   __delay();
   
   *(regDir_p) |= (1 << sclBitNr);  // Set SCL low
   
   PLTFRM_delay10MicroSecs();
   __delay();
   
   return rc;
}


UINT8_t I2C_SW_wrByte(UINT8_t busId, UINT8_t data)
{ 
   UINT8_t rc = 1, regVal, idx;
   volatile UINT8_t *regDir_p;
   volatile UINT8_t const *regIn_p;
   UINT8_t sclBitNr, sdaBitNr;   
   
   switch (busId)
   {
       case PLTFRM_I2C_SW_BUS_1_ID: 
#ifdef WISENSE_HW_REV_4
            regDir_p = &P3DIR;
            regIn_p = &P3IN;
            sclBitNr = 0x2; // p3.2
            sdaBitNr = 0x3; // p3.3
#elif defined(WISENSE_HW_REV_5)
           regDir_p = &P1DIR;
           regIn_p = &P1IN;
           sclBitNr = 0x6; // p4.1
           sdaBitNr = 0x7; // p4.2
#elif defined(WISENSE_HW_REV_6)
           regDir_p = &P3DIR;
           regIn_p = &P3IN;
           sclBitNr = 0x7; // p3.7
           sdaBitNr = 0x6; // p3.6
#else
#error hw revision not specified !!
#endif
            break;
            
       default:
            rc = 0;
            break;
   }
    
   if (rc == 0)
       return rc;
   
   // Data is transferred with the most significant bit (MSB) first.
   
   for (idx=0; idx<8; idx++)
   {  
       // Data is changed when SCL is low. 
       // Assume SCL is low at this point
     
       if (data & 0x80)
           *(regDir_p) &= ~(1 << sdaBitNr);  // Pull SDA high   
       else
           *(regDir_p) |= (1 << sdaBitNr);   // Set SDA low
     
       // Data setup time (minimum wait value is 250 nanosecs @ 100 kHz)
       PLTFRM_delay10MicroSecs();
       __delay();

       // Data should be stable during SCL high
       *(regDir_p) &= ~(1 << sclBitNr);  // Pull SCL high
       
       // SCL pulse width high (minimum wait value is max 4 microseconds @ 100 kHz)
       PLTFRM_delay10MicroSecs();
       __delay();
       
       *(regDir_p) |= (1 << sclBitNr);  // Set SCL low
       
       // SDA hold time is 0 
       PLTFRM_delay10MicroSecs();
       __delay();
       
       *(regDir_p) &= ~(1 << sdaBitNr);  // release SDA

       // SCL pulse width low (minimum value is max 2 microseconds)
       PLTFRM_delay10MicroSecs();
       __delay();
       
       data <<= 1;
   }
   
   /*
    * The 9th bit of the frame is the NACK/ACK bit. This is the case for all frames
    * (data or address). Once the first 8 bits of the frame are sent, the receiving
    * device is given control over SDA. If the receiving device does not pull the SDA
    * line low before the 9th clock pulse, it can be inferred that the receiving device
    * either did not receive the data or did not know how to parse the message. In that
    * case, the exchange halts, and it�s up to the master of the system to decide how
    * to proceed.
    */

   // Read the SDA line (we have already waited 10 microseconds after setting SCL low
   // and releasing SDA)
   regVal = *(regIn_p);

   if (regVal & (1 << sdaBitNr))
   {
       rc = 0;
   }

   // Data should be stable during SCL high
   *(regDir_p) &= ~(1 << sclBitNr);  // Pull SCL high

   // SCL pulse width high (minimum wait value is max 4 microseconds @ 100 kHz)
   PLTFRM_delay10MicroSecs(); // hack
   __delay();
   
   *(regDir_p) |= (1 << sclBitNr);  // Set SCL low

   PLTFRM_delay10MicroSecs();
   __delay();
   return rc;
}


PLTFRM_sts_t I2C_SW_clkLowDataLow(UINT8_t busId)
{
   volatile UINT8_t *regDir_p;
   UINT8_t sclBitNr, sdaBitNr;
   PLTFRM_sts_t sts = PLTFRM_STS_SUCCESS;

   switch (busId)
   {
       case PLTFRM_I2C_SW_BUS_1_ID:
#ifdef WISENSE_HW_REV_4
            regDir_p = &P3DIR;
            regIn_p = &P3IN;
            sdaBitNr = 0x3; // p3.3
#elif defined(WISENSE_HW_REV_5)
            regDir_p = &P1DIR;
            regIn_p = &P1IN;
            sdaBitNr = 0x7; // p1.7
#elif defined(WISENSE_HW_REV_6)
            regDir_p = &P3DIR;
            sclBitNr = 0x7; // p3.7
            sdaBitNr = 0x6; // p3.6
#else
#error hw revision not specified !!
#endif
            break;

       default:
            sts = PLTFRM_STS_INV_I2C_BUS_ID;
            break;
   }

   if (sts != PLTFRM_STS_SUCCESS)
       return sts;

   *(regDir_p) |= (1 << sclBitNr);  // Set SCL low

   PLTFRM_delay10MicroSecs();

   *(regDir_p) |= (1 << sdaBitNr);  // Set SDA low

   PLTFRM_delay10MicroSecs();

   return sts;
}

PLTFRM_sts_t I2C_SW_clkHiDataHi(UINT8_t busId)
{
   volatile UINT8_t *regDir_p;
   UINT8_t sclBitNr, sdaBitNr;
   PLTFRM_sts_t sts = PLTFRM_STS_SUCCESS;

   switch (busId)
   {
       case PLTFRM_I2C_SW_BUS_1_ID:
#ifdef WISENSE_HW_REV_4
            regDir_p = &P3DIR;
            regIn_p = &P3IN;
            sdaBitNr = 0x3; // p3.3
#elif defined(WISENSE_HW_REV_5)
            regDir_p = &P1DIR;
            regIn_p = &P1IN;
            sdaBitNr = 0x7; // p1.7
#elif defined(WISENSE_HW_REV_6)
            regDir_p = &P3DIR;
            sclBitNr = 0x7; // p3.7
            sdaBitNr = 0x6; // p3.6
#else
#error hw revision not specified !!
#endif
            break;

       default:
            sts = PLTFRM_STS_INV_I2C_BUS_ID;
            break;
   }

   if (sts != PLTFRM_STS_SUCCESS)
       return sts;

   *(regDir_p) &= ~(1 << sdaBitNr);  // Pull SDA high

   PLTFRM_delay10MicroSecs();

   *(regDir_p) &= ~(1 << sclBitNr);  // Pull SCL high

   PLTFRM_delay10MicroSecs();

   return sts;
}


PLTFRM_sts_t I2C_SW_readDataLine(UINT8_t busId, UINT8_t *sigVal_p)
{
   UINT8_t regVal, sdaBitNr;
   volatile UINT8_t *regDir_p;
   volatile UINT8_t const *regIn_p;
   PLTFRM_sts_t sts = PLTFRM_STS_SUCCESS;

   switch (busId)
   {
       case PLTFRM_I2C_SW_BUS_1_ID: 
#ifdef WISENSE_HW_REV_4
            regDir_p = &P3DIR;
            regIn_p = &P3IN;
            sdaBitNr = 0x3; // p3.3
#elif defined(WISENSE_HW_REV_5)
            regDir_p = &P1DIR;
            regIn_p = &P1IN;
            sdaBitNr = 0x7; // p1.7
#elif defined(WISENSE_HW_REV_6)
            regDir_p = &P3DIR;
            regIn_p = &P3IN;
            sdaBitNr = 0x6; // p3.6
#else
#error hw revision not specified !!
#endif
            break;
            
       default:
            sts = PLTFRM_STS_INV_I2C_BUS_ID;
            break;
   }
    
   if (sts != PLTFRM_STS_SUCCESS)
       return sts;

   *(regDir_p) &= ~(1 << sdaBitNr);  // release SDA (it should already be released)
   PLTFRM_delay10MicroSecs();
   regVal = *(regIn_p);

   *sigVal_p = (regVal & (1 << sdaBitNr)) ? 0x1 : 0x0;

   return sts;
}


UINT8_t I2C_SW_sendDevAddr_7(UINT8_t busId, UINT8_t i2cAddr, UINT8_t opnType)
{
   UINT8_t rc = 0, slaveAddrByte = i2cAddr;
   
   /*
    * 8.0 FORMATS WITH 7-BIT ADDRESSES
    * After the START condition (S), a slave address is sent. This address is 7 bits
    * long followed by an eighth bit which is a data direction bit (R/W) - a zero
    * indicates a transmission (WRITE), a one indicates a request for data (READ).
    */
   
   slaveAddrByte = (slaveAddrByte << 1) & 0xfe;
   slaveAddrByte |= (opnType == I2C_OPN_TYPE_READ) ? 0x1 : 0x0;
   
   rc = I2C_SW_wrByte(busId, slaveAddrByte);
   
   return rc;
}


UINT8_t I2C_SW_init(UINT8_t busId)
{
   UINT8_t sclBitMsk, sdaBitMsk, rc = 1;   
   
   switch (busId)
   {
       case PLTFRM_I2C_SW_BUS_1_ID: 
#ifdef WISENSE_HW_REV_4
            sclBitMsk = (1 << 2); // p3.2
            sdaBitMsk = (1 << 3); // p3.3   
            P3DIR &= ~(sclBitMsk | sdaBitMsk);  // Input direction
            P3SEL &= ~(sclBitMsk | sdaBitMsk);  // I/O functionality
            P3SEL2 &= ~(sclBitMsk | sdaBitMsk);
            P3REN &= ~(sclBitMsk | sdaBitMsk);  // Pull up resistor disabled
            P3OUT &= ~(sclBitMsk | sdaBitMsk);  
#elif defined(WISENSE_HW_REV_5)
            sclBitMsk = BIT6; // p1.6
            sdaBitMsk = BIT7; // p1.7
            P1DIR &= ~(sclBitMsk | sdaBitMsk);  // Input direction
            P1SEL &= ~(sclBitMsk | sdaBitMsk);  // I/O functionality
            P1SEL2 &= ~(sclBitMsk | sdaBitMsk);
            P1REN &= ~(sclBitMsk | sdaBitMsk);  // Pull up resistor disabled
            P1OUT &= ~(sclBitMsk | sdaBitMsk);
#elif defined(WISENSE_HW_REV_6)
            sclBitMsk = BIT7; // p3.7
            sdaBitMsk = BIT6; // p3.6
            P3DIR &= ~(sclBitMsk | sdaBitMsk);  // Input direction
            P3SEL &= ~(sclBitMsk | sdaBitMsk);  // I/O functionality
            P3SEL2 &= ~(sclBitMsk | sdaBitMsk);
            P3REN &= ~(sclBitMsk | sdaBitMsk);  // Pull up resistor disabled
            P3OUT &= ~(sclBitMsk | sdaBitMsk);

            {
               PLTFRM_sts_t sts;

               sts = PLTFRM_reserveGPIOPin(PLTFRM_I2C_SW_BUS_1_DEV_ID, PLTFRM_GPIO_PORT_3, PLTFRM_GPIO_PORT_PIN_6);
               if (sts != PLTFRM_STS_SUCCESS)
                   return 0;

               sts = PLTFRM_reserveGPIOPin(PLTFRM_I2C_SW_BUS_1_DEV_ID, PLTFRM_GPIO_PORT_3, PLTFRM_GPIO_PORT_PIN_7);
               if (sts != PLTFRM_STS_SUCCESS)
                   return 0;
           }
#else
#error hw revision not specified !!
#endif

            break;
            
       default:
            rc = 0;
            break;
   }
    
   return rc;
}

#endif
